# 트리
- N개의 정점과 N-1개의 양방향 간선으로 이루어져 잇음
- 사이클이 존재하지 않는 그래프
- <b>임의의 두 정점을 연결하는 단순 경로가 유일한 그래프</b>
- <b>임의의 간선을 제거하면, 그래프가 여러 연결 컴포넌트로 나눠지는 그래프</b>
- 이진 트리 : 각 정점이 최대 두 개의 자식
- 포화 이진 트리 : 리프 정점을 제외한 모든 정점이 두 개의 자식을 가지며서 추가로 모든 리프 정점의 높이가 동일한 트리

## DFS
- 뻗어나가듯이 방문 순서를 정한다.
- 그래서 방문할 수 이는 정점 후보를 관리할 때 큐 대신 스택을 사용
- 하지만 문제 풀 때는 스택의 원리와 동일하게 동작하는 재귀 함수를 사용
- 예시
```
from collections import deque

N, M = map(int, input().split())
V = [0 for _ in range(N + 1)]
G = [[] for _ in range(N + 1)]
for _ in range(M):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)  

ST = []
def DFS(cur):
    print(f"현재 정점: {cur}, 현재 탐색하고 있는 경로: {ST}")
    for next in G[cur]:
        # DFS 역시 모든 정점을 한 번씩만 방문해야 하므로, 이미 방문한 정점은 건너뜁니다.
        if V[next]:
            continue
        # 실제로 스택을 사용할 필요는 없지만, DFS의 동작 과정을 보여주기 위해 스택을 사용했습니다.
        ST.append(next)
        V[next] = 1
        DFS(next)
    ST.pop()
    print(f"더 탐색할 수 있는 경로가 없으므로 pop, 현재 탐색하고 있는 경로: {ST}")
    
ST.append(1)
V[1] = 1
DFS(1)

'''
INPUT
6 6
1 2
1 4
2 3
2 5
2 6
4 5

OUTPUT
현재 정점: 1, 현재 탐색하고 있는 경로: [1]
현재 정점: 2, 현재 탐색하고 있는 경로: [1, 2]
현재 정점: 3, 현재 탐색하고 있는 경로: [1, 2, 3]
더 탐색할 수 있는 경로가 없으므로 pop, 현재 탐색하고 있는 경로: [1, 2]
현재 정점: 5, 현재 탐색하고 있는 경로: [1, 2, 5]
현재 정점: 4, 현재 탐색하고 있는 경로: [1, 2, 5, 4]
더 탐색할 수 있는 경로가 없으므로 pop, 현재 탐색하고 있는 경로: [1, 2, 5]
더 탐색할 수 있는 경로가 없으므로 pop, 현재 탐색하고 있는 경로: [1, 2]
현재 정점: 6, 현재 탐색하고 있는 경로: [1, 2, 6]
더 탐색할 수 있는 경로가 없으므로 pop, 현재 탐색하고 있는 경로: [1, 2]
더 탐색할 수 있는 경로가 없으므로 pop, 현재 탐색하고 있는 경로: [1]
더 탐색할 수 있는 경로가 없으므로 pop, 현재 탐색하고 있는 경로: []
'''
```

## 트리에서의 DFS 탐색
- <b> 임의의 두 정점을 연결하는 단순 경로가 유일하다.</b>
- 그래서 고려하는 경로의 개수가 그렇게 많지 않다.
- DFS(h, n, score) : 높이 h의 n번째 정점을 탐색 중, 지나온 경로의 점수 합이 score
- 이동할 때마다 score에서는 현재 칸의 알파벳에 해당하는 점수가 추가되고, 더 이동 못하면(=리프 정점일 때) 최종 답 갱신
```
def DFS(h, n, score):
    # 경로에 현재 칸의 점수를 더합니다.
    score += ord(S[h][n]) - ord('A') + 1
    
    # 리프 정점이 아닌 경우에는 탐색을 계속 진행합니다.
    if h < N:
        DFS(h + 1, n * 2, score)
        DFS(h + 1, n * 2 + 1, score)
    # 리프 정점인 경우에는 답을 갱신합니다.
    else:
        global ans1, ans2
        ans1 = min(ans1, score)
        ans2 = max(ans2, score)
```
- 시간복잡도 O(2^N)




