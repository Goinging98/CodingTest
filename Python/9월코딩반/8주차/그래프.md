# 그래프

### 그래프 구성 요소
- 정점
- 간선

## 그래프의 표현 
### 인접행렬
![image](https://github.com/Goinging98/CodingTest/assets/38778937/100980c2-5dd0-4fec-a553-6f3a61fda414)
<br/>
- 인접행렬은 두 표현 방식 중에서 조금 더 직관적으로 연결관계를 나타내는 방식
- NxM 크기의 2차원 배열을 선언하고 초기값은 모두 0으로 설정(양방향 그래프)
- a번 정점에서 b번 정점으로 가는 간선이 존재하면, a행 b열 칸을 1로 바꾼다.
- 이럴 때는 시간복잡도 O(1)에 알 수 있지만, 메모리 복잡도가 너무 크다.

### 인접 리스트
- 어떤 정점에서 간선으로 이동할 수 있는 정점만 관리하는 표현방식
- list의 동적 배열을 사용한다.
- N은 정점의 개수, M은 간선의 개수입니다.

```
N, M = map(int, input().split())
G = [[] for _ in range(N + 1)]
for _ in range(M):
    # a와 b를 잇는 양방향 간선이 존재한다고 합시다.
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)
print(G[1:])
'''
INPUT
6 6
1 2
1 4
2 3
2 5
2 6
4 5

OUTPUT
[[2, 4], [1, 3, 5, 6], [2], [1, 5], [2, 4], [2]]
'''
```
- 공간복잡도에서 효율적이지만, 두 정점을 연결하는 간선이 존재하는지 빠르게 파악하기 어렵다.


## 그래프 탐색
- 간선을 따라서 그래프의 모든 정점을 방문한느 과정
### 너비우선 탐색 BFS
- 시작 정점으로부터 가까이 있는 정점부터 탐색
- 탐색 후보에 먼저 들어간 순서대로 정점을 방문하므로, 큐를 이용해서 구현한다.
```
from collections import deque

N, M = map(int, input().split())
V = [0 for _ in range(N + 1)]
G = [[] for _ in range(N + 1)]
for _ in range(M):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)
    
Q = deque()
# 1번 정점에서 탐색을 시작해봅시다.
V[1] = 1
Q.append(1)

# BFS는 큐에 있는 정점이 모두 없어질 때까지, 즉 모든 정점을 한 번씩 방문할 때까지 반복합니다.
while Q:
    # 가장 왼쪽에 있는 정점이 가장 먼저 들어간 정점입니다.
    cur = Q.popleft()
    # 다음으로 방문할 정점의 후보들을 추가해줍니다.
    for next in G[cur]:
        # 그래프 탐색은 모든 정점을 한 번씩만 방문해야 하므로, 이미 큐에 들어간 정점은 반드시 건너뛰어야 합니다.
        if V[next]:
            continue
        # 반드시 큐에 들어가기 전에 방문 체크를 해야합니다. 그렇지 않을 경우에는 큐에 같은 정점이 중복해서 들어가는 일이 일어납니다.
        V[next] = 1
        Q.append(next)
    print(f"현재 정점: {cur}, 다음에 방문할 정점의 순서: {Q}")

'''
위의 입력을 다시 한 번 넣어봅시다.

OUTPUT
현재 정점: 1, 다음에 방문할 정점의 순서: deque([2, 4])
현재 정점: 2, 다음에 방문할 정점의 순서: deque([4, 3, 5, 6])
현재 정점: 4, 다음에 방문할 정점의 순서: deque([3, 5, 6])
현재 정점: 3, 다음에 방문할 정점의 순서: deque([5, 6])
현재 정점: 5, 다음에 방문할 정점의 순서: deque([6])
현재 정점: 6, 다음에 방문할 정점의 순서: deque([])
'''
```

#### 최단 거리 구하기 
- BFS는 모든 간선의 가중치가 동일한 그래프에서 최단 거리를 구할 때 사용
- 항상 가까이에 있는 정점을 우선적으로 방문하기 때문에, 시작 정점과 다른 모든 정점 간의 최단거리가 짧은 순으로 탐색을 진행
- 시간복잡도 : O(N+M)
```
from collections import deque

N, M = map(int, input().split())
# 초기에는 모든 정점의 거리를 적당히 큰 값으로 초기화해줍니다.
D = [9**9 for _ in range(N + 1)]
G = [[] for _ in range(N + 1)]
for _ in range(M):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)
    
Q = deque()
# 1번 정점은 시작 정점이니 거리를 0으로 둡니다.
D[1] = 0
Q.append(1)

while Q:
    cur = Q.popleft()
    for next in G[cur]:
        # BFS는 아직 방문하지 않은 정점만 큐에 넣어야 합니다.
        # 이미 방문한 정점이라면 거리가 초기값으로 설정해둔 값보단 작을테니, 앞서 사용했던 visit 배열을 사용하지 않고도 판별이 가능합니다.
        # 추가로 큐에 들어있을 수 있는 정점들의 최단 거리는 현재 정점과 최대 1까지 밖에 차이날 수 없습니다. 왜 그런지는 한 번 생각해봅시다 :D
        if D[next] <= D[cur] + 1:
            continue
        # 다음 정점의 거리를 갱신해줍니다.
        D[next] = D[cur] + 1
        Q.append(next)
    print(f"현재 정점: {cur}, 1번 정점과 {cur}번 정점과의 최단 거리는 {D[cur]}")

'''
OUTPUT
현재 정점: 1, 1번 정점과 1번 정점과의 최단 거리는 0
현재 정점: 2, 1번 정점과 2번 정점과의 최단 거리는 1
현재 정점: 4, 1번 정점과 4번 정점과의 최단 거리는 1
현재 정점: 3, 1번 정점과 3번 정점과의 최단 거리는 2
현재 정점: 5, 1번 정점과 5번 정점과의 최단 거리는 2
현재 정점: 6, 1번 정점과 6번 정점과의 최단 거리는 2
'''
```







